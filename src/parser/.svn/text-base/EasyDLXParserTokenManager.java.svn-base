/**
 Copyright (c) 2011 Daniele Biagi
Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE 
OR OTHER DEALINGS IN THE SOFTWARE.
 */
package parser;
/* Generated By:JavaCC: Do not edit this line. EasyDLXParserTokenManager.java */

/** Token Manager. */
public class EasyDLXParserTokenManager implements EasyDLXParserConstants
{

  /** Debug output. */
  public static  java.io.PrintStream debugStream = System.out;
  /** Set debug output. */
  public static  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private static final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xfffe1ffffffffffeL) != 0L || (active1 & 0x3ffffL) != 0L)
         {
            jjmatchedKind = 86;
            return 9;
         }
         if ((active0 & 0x1e00000000000L) != 0L)
            return 9;
         return -1;
      case 1:
         if ((active0 & 0x35807fdfffbfeL) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 86;
               jjmatchedPos = 1;
            }
            return 9;
         }
         if ((active0 & 0xfffc27f802000400L) != 0L || (active1 & 0x3ffffL) != 0L)
            return 9;
         return -1;
      case 2:
         if ((active0 & 0x180000000060L) != 0L)
         {
            if (jjmatchedPos != 2)
            {
               jjmatchedKind = 86;
               jjmatchedPos = 2;
            }
            return 9;
         }
         if ((active0 & 0xf0034057fffffb9eL) != 0L || (active1 & 0x3ffffL) != 0L)
            return 9;
         return -1;
      case 3:
         if ((active0 & 0x5807fdf00174L) != 0L)
            return 9;
         return -1;
      default :
         return -1;
   }
}
private static final int jjStartNfa_0(int pos, long active0, long active1)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
}
static private int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
static private int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 40:
         return jjStopAtPos(0, 91);
      case 41:
         return jjStopAtPos(0, 92);
      case 44:
         return jjStopAtPos(0, 90);
      case 59:
         return jjStopAtPos(0, 94);
      case 65:
         return jjMoveStringLiteralDfa1_0(0x1300206L, 0x0L);
      case 66:
         return jjMoveStringLiteralDfa1_0(0x180000000000L, 0x0L);
      case 68:
         return jjMoveStringLiteralDfa1_0(0x180L, 0x0L);
      case 74:
         jjmatchedKind = 47;
         return jjMoveStringLiteralDfa1_0(0x1600000000000L, 0x0L);
      case 76:
         return jjMoveStringLiteralDfa1_0(0xf800000000L, 0x0L);
      case 77:
         return jjMoveStringLiteralDfa1_0(0x60L, 0x0L);
      case 78:
         return jjMoveStringLiteralDfa1_0(0x2000000000000L, 0x0L);
      case 79:
         return jjMoveStringLiteralDfa1_0(0x2000400L, 0x0L);
      case 82:
         return jjMoveStringLiteralDfa1_0(0xfffc000000000000L, 0x3ffffL);
      case 83:
         return jjMoveStringLiteralDfa1_0(0x707f8cff018L, 0x0L);
      case 88:
         return jjMoveStringLiteralDfa1_0(0x4000800L, 0x0L);
      default :
         return jjMoveNfa_0(2, 0);
   }
}
static private int jjMoveStringLiteralDfa1_0(long active0, long active1)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0, active1);
      return 1;
   }
   switch(curChar)
   {
      case 48:
         if ((active0 & 0x4000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 50, 9);
         break;
      case 49:
         if ((active0 & 0x8000000000000L) != 0L)
         {
            jjmatchedKind = 51;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0xf000000000000000L, active1, 0x3fL);
      case 50:
         if ((active0 & 0x10000000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0xffc0L);
      case 51:
         if ((active0 & 0x20000000000000L) != 0L)
         {
            jjmatchedKind = 53;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x30000L);
      case 52:
         if ((active0 & 0x40000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 54, 9);
         break;
      case 53:
         if ((active0 & 0x80000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 55, 9);
         break;
      case 54:
         if ((active0 & 0x100000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 56, 9);
         break;
      case 55:
         if ((active0 & 0x200000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 57, 9);
         break;
      case 56:
         if ((active0 & 0x400000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 58, 9);
         break;
      case 57:
         if ((active0 & 0x800000000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 59, 9);
         break;
      case 65:
         return jjMoveStringLiteralDfa2_0(active0, 0x1400000000000L, active1, 0L);
      case 66:
         if ((active0 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 35;
            jjmatchedPos = 1;
         }
         else if ((active0 & 0x10000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 40, 9);
         return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L);
      case 68:
         return jjMoveStringLiteralDfa2_0(active0, 0x300006L, active1, 0L);
      case 69:
         return jjMoveStringLiteralDfa2_0(active0, 0x80200040000L, active1, 0L);
      case 71:
         return jjMoveStringLiteralDfa2_0(active0, 0x140028000L, active1, 0L);
      case 72:
         if ((active0 & 0x2000000000L) != 0L)
         {
            jjmatchedKind = 37;
            jjmatchedPos = 1;
         }
         else if ((active0 & 0x20000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 41, 9);
         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000L, active1, 0L);
      case 73:
         return jjMoveStringLiteralDfa2_0(active0, 0x180L, active1, 0L);
      case 76:
         return jjMoveStringLiteralDfa2_0(active0, 0xa8015000L, active1, 0L);
      case 78:
         return jjMoveStringLiteralDfa2_0(active0, 0x100401080200L, active1, 0L);
      case 79:
         return jjMoveStringLiteralDfa2_0(active0, 0x2000004000800L, active1, 0L);
      case 82:
         if ((active0 & 0x400L) != 0L)
         {
            jjmatchedKind = 10;
            jjmatchedPos = 1;
         }
         else if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 45, 9);
         return jjMoveStringLiteralDfa2_0(active0, 0x12002000L, active1, 0L);
      case 85:
         return jjMoveStringLiteralDfa2_0(active0, 0xc00078L, active1, 0L);
      case 87:
         if ((active0 & 0x8000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 39, 9);
         else if ((active0 & 0x40000000000L) != 0L)
            return jjStartNfaWithStates_0(1, 42, 9);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0, active1);
}
static private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(0, old0, old1);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0, active1);
      return 2;
   }
   switch(curChar)
   {
      case 48:
         if ((active0 & 0x1000000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 60, 9);
         else if ((active1 & 0x40L) != 0L)
            return jjStartNfaWithStates_0(2, 70, 9);
         else if ((active1 & 0x10000L) != 0L)
            return jjStartNfaWithStates_0(2, 80, 9);
         break;
      case 49:
         if ((active0 & 0x2000000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 61, 9);
         else if ((active1 & 0x80L) != 0L)
            return jjStartNfaWithStates_0(2, 71, 9);
         else if ((active1 & 0x20000L) != 0L)
            return jjStartNfaWithStates_0(2, 81, 9);
         break;
      case 50:
         if ((active0 & 0x4000000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 62, 9);
         else if ((active1 & 0x100L) != 0L)
            return jjStartNfaWithStates_0(2, 72, 9);
         break;
      case 51:
         if ((active0 & 0x8000000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 63, 9);
         else if ((active1 & 0x200L) != 0L)
            return jjStartNfaWithStates_0(2, 73, 9);
         break;
      case 52:
         if ((active1 & 0x1L) != 0L)
            return jjStartNfaWithStates_0(2, 64, 9);
         else if ((active1 & 0x400L) != 0L)
            return jjStartNfaWithStates_0(2, 74, 9);
         break;
      case 53:
         if ((active1 & 0x2L) != 0L)
            return jjStartNfaWithStates_0(2, 65, 9);
         else if ((active1 & 0x800L) != 0L)
            return jjStartNfaWithStates_0(2, 75, 9);
         break;
      case 54:
         if ((active1 & 0x4L) != 0L)
            return jjStartNfaWithStates_0(2, 66, 9);
         else if ((active1 & 0x1000L) != 0L)
            return jjStartNfaWithStates_0(2, 76, 9);
         break;
      case 55:
         if ((active1 & 0x8L) != 0L)
            return jjStartNfaWithStates_0(2, 67, 9);
         else if ((active1 & 0x2000L) != 0L)
            return jjStartNfaWithStates_0(2, 77, 9);
         break;
      case 56:
         if ((active1 & 0x10L) != 0L)
            return jjStartNfaWithStates_0(2, 68, 9);
         else if ((active1 & 0x4000L) != 0L)
            return jjStartNfaWithStates_0(2, 78, 9);
         break;
      case 57:
         if ((active1 & 0x20L) != 0L)
            return jjStartNfaWithStates_0(2, 69, 9);
         else if ((active1 & 0x8000L) != 0L)
            return jjStartNfaWithStates_0(2, 79, 9);
         break;
      case 66:
         if ((active0 & 0x8L) != 0L)
         {
            jjmatchedKind = 3;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0xc00010L, active1, 0L);
      case 68:
         if ((active0 & 0x2L) != 0L)
         {
            jjmatchedKind = 1;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x200L) != 0L)
         {
            jjmatchedKind = 9;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x1300004L, active1, 0L);
      case 69:
         if ((active0 & 0x10000L) != 0L)
         {
            jjmatchedKind = 16;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x20000L) != 0L)
         {
            jjmatchedKind = 17;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x80000L) != 0L)
         {
            jjmatchedKind = 19;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x100580000000L, active1, 0L);
      case 73:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_0(2, 25, 9);
         break;
      case 76:
         if ((active0 & 0x1000L) != 0L)
         {
            jjmatchedKind = 12;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x2000L) != 0L)
         {
            jjmatchedKind = 13;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x1000000000000L) != 0L)
         {
            jjmatchedKind = 48;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x400018000060L, active1, 0L);
      case 80:
         if ((active0 & 0x2000000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 49, 9);
         break;
      case 81:
         if ((active0 & 0x40000L) != 0L)
         {
            jjmatchedKind = 18;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x80200000000L, active1, 0L);
      case 82:
         if ((active0 & 0x800L) != 0L)
         {
            jjmatchedKind = 11;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L, active1, 0L);
      case 84:
         if ((active0 & 0x4000L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 2;
         }
         else if ((active0 & 0x8000L) != 0L)
         {
            jjmatchedKind = 15;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x60000000L, active1, 0L);
      case 85:
         if ((active0 & 0x1000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 36, 9);
         else if ((active0 & 0x4000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 38, 9);
         break;
      case 86:
         if ((active0 & 0x80L) != 0L)
         {
            jjmatchedKind = 7;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x100L, active1, 0L);
      default :
         break;
   }
   return jjStartNfa_0(1, active0, active1);
}
static private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(1, old0, old1);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0, 0L);
      return 3;
   }
   switch(curChar)
   {
      case 73:
         if ((active0 & 0x100000L) != 0L)
            return jjStartNfaWithStates_0(3, 20, 9);
         else if ((active0 & 0x400000L) != 0L)
            return jjStartNfaWithStates_0(3, 22, 9);
         else if ((active0 & 0x1000000L) != 0L)
            return jjStartNfaWithStates_0(3, 24, 9);
         else if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(3, 26, 9);
         else if ((active0 & 0x8000000L) != 0L)
            return jjStartNfaWithStates_0(3, 27, 9);
         else if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(3, 28, 9);
         else if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(3, 29, 9);
         else if ((active0 & 0x40000000L) != 0L)
            return jjStartNfaWithStates_0(3, 30, 9);
         else if ((active0 & 0x80000000L) != 0L)
            return jjStartNfaWithStates_0(3, 31, 9);
         else if ((active0 & 0x100000000L) != 0L)
            return jjStartNfaWithStates_0(3, 32, 9);
         else if ((active0 & 0x200000000L) != 0L)
            return jjStartNfaWithStates_0(3, 33, 9);
         else if ((active0 & 0x400000000L) != 0L)
            return jjStartNfaWithStates_0(3, 34, 9);
         break;
      case 82:
         if ((active0 & 0x400000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 46, 9);
         break;
      case 84:
         if ((active0 & 0x20L) != 0L)
         {
            jjmatchedKind = 5;
            jjmatchedPos = 3;
         }
         return jjMoveStringLiteralDfa4_0(active0, 0x40L);
      case 85:
         if ((active0 & 0x4L) != 0L)
         {
            jjmatchedKind = 2;
            jjmatchedPos = 3;
         }
         else if ((active0 & 0x10L) != 0L)
         {
            jjmatchedKind = 4;
            jjmatchedPos = 3;
         }
         else if ((active0 & 0x100L) != 0L)
            return jjStartNfaWithStates_0(3, 8, 9);
         return jjMoveStringLiteralDfa4_0(active0, 0xa00000L);
      case 90:
         if ((active0 & 0x80000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 43, 9);
         else if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 44, 9);
         break;
      default :
         break;
   }
   return jjStartNfa_0(2, active0, 0L);
}
static private int jjMoveStringLiteralDfa4_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(2, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 73:
         if ((active0 & 0x200000L) != 0L)
            return jjStartNfaWithStates_0(4, 21, 9);
         else if ((active0 & 0x800000L) != 0L)
            return jjStartNfaWithStates_0(4, 23, 9);
         break;
      case 85:
         if ((active0 & 0x40L) != 0L)
            return jjStartNfaWithStates_0(4, 6, 9);
         break;
      default :
         break;
   }
   return jjStartNfa_0(3, active0, 0L);
}
static private int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
static private int jjMoveNfa_0(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 9;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 9:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(6, 7);
                  else if (curChar == 58)
                  {
                     if (kind > 87)
                        kind = 87;
                  }
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 86)
                        kind = 86;
                     jjCheckNAdd(5);
                  }
                  break;
               case 2:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 89)
                        kind = 89;
                  }
                  else if ((0x280000000000L & l) != 0L)
                  {
                     if (kind > 93)
                        kind = 93;
                     jjstateSet[jjnewStateCnt++] = 0;
                  }
                  if ((0x3fe000000000000L & l) != 0L)
                  {
                     if (kind > 88)
                        kind = 88;
                     jjCheckNAdd(1);
                  }
                  else if (curChar == 48)
                  {
                     if (kind > 88)
                        kind = 88;
                  }
                  break;
               case 0:
                  if ((0x3fe000000000000L & l) == 0L)
                     break;
                  if (kind > 88)
                     kind = 88;
                  jjCheckNAdd(1);
                  break;
               case 1:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 88)
                     kind = 88;
                  jjCheckNAdd(1);
                  break;
               case 3:
                  if ((0x3ff000000000000L & l) != 0L && kind > 89)
                     kind = 89;
                  break;
               case 5:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 86)
                     kind = 86;
                  jjCheckNAdd(5);
                  break;
               case 6:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(6, 7);
                  break;
               case 7:
                  if (curChar == 58)
                     kind = 87;
                  break;
               case 8:
                  if ((0x280000000000L & l) == 0L)
                     break;
                  kind = 93;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 9:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(6, 7);
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 86)
                        kind = 86;
                     jjCheckNAdd(5);
                  }
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 86)
                     kind = 86;
                  jjCheckNAddStates(0, 2);
                  break;
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 86)
                     kind = 86;
                  jjCheckNAdd(5);
                  break;
               case 6:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(6, 7);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 9 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   5, 6, 7, 
};

/** Token literal values. */
public static final String[] jjstrLiteralImages = {
"", "\101\104\104", "\101\104\104\125", "\123\125\102", "\123\125\102\125", 
"\115\125\114\124", "\115\125\114\124\125", "\104\111\126", "\104\111\126\125", "\101\116\104", 
"\117\122", "\130\117\122", "\123\114\114", "\123\122\114", "\123\114\124", 
"\123\107\124", "\123\114\105", "\123\107\105", "\123\105\121", "\123\116\105", 
"\101\104\104\111", "\101\104\104\125\111", "\123\125\102\111", "\123\125\102\125\111", 
"\101\116\104\111", "\117\122\111", "\130\117\122\111", "\123\114\114\111", "\123\122\114\111", 
"\123\114\124\111", "\123\107\124\111", "\123\114\105\111", "\123\107\105\111", 
"\123\105\121\111", "\123\116\105\111", "\114\102", "\114\102\125", "\114\110", "\114\110\125", 
"\114\127", "\123\102", "\123\110", "\123\127", "\102\105\121\132", "\102\116\105\132", 
"\112\122", "\112\101\114\122", "\112", "\112\101\114", "\116\117\120", "\122\60", 
"\122\61", "\122\62", "\122\63", "\122\64", "\122\65", "\122\66", "\122\67", "\122\70", 
"\122\71", "\122\61\60", "\122\61\61", "\122\61\62", "\122\61\63", "\122\61\64", 
"\122\61\65", "\122\61\66", "\122\61\67", "\122\61\70", "\122\61\71", "\122\62\60", 
"\122\62\61", "\122\62\62", "\122\62\63", "\122\62\64", "\122\62\65", "\122\62\66", 
"\122\62\67", "\122\62\70", "\122\62\71", "\122\63\60", "\122\63\61", null, null, null, null, 
null, null, null, null, "\54", "\50", "\51", null, "\73", null, };

/** Lexer state names. */
public static final String[] lexStateNames = {
   "DEFAULT",
};
static final long[] jjtoToken = {
   0xffffffffffffffffL, 0xffc3ffffL, 
};
static final long[] jjtoSkip = {
   0x0L, 0x3c0000L, 
};
static protected SimpleCharStream input_stream;
static private final int[] jjrounds = new int[9];
static private final int[] jjstateSet = new int[18];
static protected char curChar;
/** Constructor. */
public EasyDLXParserTokenManager(SimpleCharStream stream){
   if (input_stream != null)
      throw new TokenMgrError("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", TokenMgrError.STATIC_LEXER_ERROR);
   input_stream = stream;
}

/** Constructor. */
public EasyDLXParserTokenManager(SimpleCharStream stream, int lexState){
   this(stream);
   SwitchTo(lexState);
}

/** Reinitialise parser. */
static public void ReInit(SimpleCharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
static private void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 9; i-- > 0;)
      jjrounds[i] = 0x80000000;
}

/** Reinitialise parser. */
static public void ReInit(SimpleCharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}

/** Switch to specified lex state. */
static public void SwitchTo(int lexState)
{
   if (lexState >= 1 || lexState < 0)
      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

static protected Token jjFillToken()
{
   final Token t;
   final String curTokenImage;
   final int beginLine;
   final int endLine;
   final int beginColumn;
   final int endColumn;
   String im = jjstrLiteralImages[jjmatchedKind];
   curTokenImage = (im == null) ? input_stream.GetImage() : im;
   beginLine = input_stream.getBeginLine();
   beginColumn = input_stream.getBeginColumn();
   endLine = input_stream.getEndLine();
   endColumn = input_stream.getEndColumn();
   t = Token.newToken(jjmatchedKind, curTokenImage);

   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;

   return t;
}

static int curLexState = 0;
static int defaultLexState = 0;
static int jjnewStateCnt;
static int jjround;
static int jjmatchedPos;
static int jjmatchedKind;

/** Get the next Token. */
public static Token getNextToken() 
{
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(java.io.IOException e)
   {
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      return matchedToken;
   }

   try { input_stream.backup(0);
      while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
         curChar = input_stream.BeginToken();
   }
   catch (java.io.IOException e1) { continue EOFLoop; }
   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         return matchedToken;
      }
      else
      {
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? "" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? "" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}

static private void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
static private void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
static private void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}

static private void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}

}
