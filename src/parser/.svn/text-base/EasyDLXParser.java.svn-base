/**
 Copyright (c) 2011 Daniele Biagi
Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE 
OR OTHER DEALINGS IN THE SOFTWARE.
 */
package parser;
/* Generated By:JavaCC: Do not edit this line. EasyDLXParser.java */
import syntaxtree.*;
import java.util.Vector;


public class EasyDLXParser implements EasyDLXParserConstants {

  static final public Goal Goal() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Label n1;
   Instruction n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LABEL_COLON:
      n1 = Label();
        n0.addNode(n1);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    n2 = Instruction();
    n4 = jj_consume_token(SEMICOLON);
                    n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new Goal(n0,n2,n3);}
    throw new Error("Missing return statement in function");
  }

  static final public Label Label() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(LABEL_COLON);
                      n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new Label(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Instruction Instruction() throws ParseException {
   NodeChoice n0;
   Instr3Regs n1;
   Instr2RegImm n2;
   InstrLoad n3;
   InstrStore n4;
   InstrBranch n5;
   InstrJumpReg n6;
   InstrJumpLab n7;
   Nop n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      n1 = Instr3Regs();
        n0 = new NodeChoice(n1, 0);
      break;
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      n2 = Instr2RegImm();
        n0 = new NodeChoice(n2, 1);
      break;
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
      n3 = InstrLoad();
        n0 = new NodeChoice(n3, 2);
      break;
    case 40:
    case 41:
    case 42:
      n4 = InstrStore();
        n0 = new NodeChoice(n4, 3);
      break;
    case 43:
    case 44:
      n5 = InstrBranch();
        n0 = new NodeChoice(n5, 4);
      break;
    case 45:
    case 46:
      n6 = InstrJumpReg();
        n0 = new NodeChoice(n6, 5);
      break;
    case 47:
    case 48:
      n7 = InstrJumpLab();
        n0 = new NodeChoice(n7, 6);
      break;
    case 49:
      n8 = Nop();
        n0 = new NodeChoice(n8, 7);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Instruction(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Instr3Regs Instr3Regs() throws ParseException {
   Op3Regs n0;
   Register n1;
   NodeToken n2;
   Token n3;
   Register n4;
   NodeToken n5;
   Token n6;
   Register n7;
    n0 = Op3Regs();
    n1 = Register();
    n3 = jj_consume_token(COMMA);
                n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Register();
    n6 = jj_consume_token(COMMA);
                n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Register();
     {if (true) return new Instr3Regs(n0,n1,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  static final public Op3Regs Op3Regs() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
   NodeToken n31;
   Token n32;
   NodeToken n33;
   Token n34;
   NodeToken n35;
   Token n36;
   NodeToken n37;
   Token n38;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 1:
      n2 = jj_consume_token(1);
                 n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 2:
      n4 = jj_consume_token(2);
                  n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case 3:
      n6 = jj_consume_token(3);
                 n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case 4:
      n8 = jj_consume_token(4);
                  n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case 5:
      n10 = jj_consume_token(5);
                   n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case 6:
      n12 = jj_consume_token(6);
                    n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case 7:
      n14 = jj_consume_token(7);
                  n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case 8:
      n16 = jj_consume_token(8);
                   n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case 9:
      n18 = jj_consume_token(9);
                  n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case 10:
      n20 = jj_consume_token(10);
                 n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case 11:
      n22 = jj_consume_token(11);
                  n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    case 12:
      n24 = jj_consume_token(12);
                  n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11);
      break;
    case 13:
      n26 = jj_consume_token(13);
                  n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12);
      break;
    case 14:
      n28 = jj_consume_token(14);
                  n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13);
      break;
    case 15:
      n30 = jj_consume_token(15);
                  n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14);
      break;
    case 16:
      n32 = jj_consume_token(16);
                  n31 = JTBToolkit.makeNodeToken(n32);
        n0 = new NodeChoice(n31, 15);
      break;
    case 17:
      n34 = jj_consume_token(17);
                  n33 = JTBToolkit.makeNodeToken(n34);
        n0 = new NodeChoice(n33, 16);
      break;
    case 18:
      n36 = jj_consume_token(18);
                  n35 = JTBToolkit.makeNodeToken(n36);
        n0 = new NodeChoice(n35, 17);
      break;
    case 19:
      n38 = jj_consume_token(19);
                  n37 = JTBToolkit.makeNodeToken(n38);
        n0 = new NodeChoice(n37, 18);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Op3Regs(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Instr2RegImm Instr2RegImm() throws ParseException {
   Op2RegsImm n0;
   Register n1;
   NodeToken n2;
   Token n3;
   Register n4;
   NodeToken n5;
   Token n6;
   Immed n7;
    n0 = Op2RegsImm();
    n1 = Register();
    n3 = jj_consume_token(COMMA);
                n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Register();
    n6 = jj_consume_token(COMMA);
                n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Immed();
     {if (true) return new Instr2RegImm(n0,n1,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  static final public Op2RegsImm Op2RegsImm() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 20:
      n2 = jj_consume_token(20);
                  n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 21:
      n4 = jj_consume_token(21);
                   n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case 22:
      n6 = jj_consume_token(22);
                  n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case 23:
      n8 = jj_consume_token(23);
                   n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case 24:
      n10 = jj_consume_token(24);
                   n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case 25:
      n12 = jj_consume_token(25);
                  n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case 26:
      n14 = jj_consume_token(26);
                   n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case 27:
      n16 = jj_consume_token(27);
                   n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case 28:
      n18 = jj_consume_token(28);
                   n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case 29:
      n20 = jj_consume_token(29);
                   n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case 30:
      n22 = jj_consume_token(30);
                   n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    case 31:
      n24 = jj_consume_token(31);
                   n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11);
      break;
    case 32:
      n26 = jj_consume_token(32);
                   n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12);
      break;
    case 33:
      n28 = jj_consume_token(33);
                   n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13);
      break;
    case 34:
      n30 = jj_consume_token(34);
                   n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Op2RegsImm(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public InstrLoad InstrLoad() throws ParseException {
   OpLoad n0;
   Register n1;
   NodeToken n2;
   Token n3;
   Immed n4;
   NodeToken n5;
   Token n6;
   Register n7;
   NodeToken n8;
   Token n9;
    n0 = OpLoad();
    n1 = Register();
    n3 = jj_consume_token(COMMA);
                n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Immed();
    n6 = jj_consume_token(OPEN_BRACKET);
                       n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Register();
    n9 = jj_consume_token(CLOSE_BRACKET);
                        n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new InstrLoad(n0,n1,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  static final public OpLoad OpLoad() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 35:
      n2 = jj_consume_token(35);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 36:
      n4 = jj_consume_token(36);
                 n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case 37:
      n6 = jj_consume_token(37);
                n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case 38:
      n8 = jj_consume_token(38);
                 n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case 39:
      n10 = jj_consume_token(39);
                 n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OpLoad(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public InstrStore InstrStore() throws ParseException {
   OpStore n0;
   Immed n1;
   NodeToken n2;
   Token n3;
   Register n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   Register n9;
    n0 = OpStore();
    n1 = Immed();
    n3 = jj_consume_token(OPEN_BRACKET);
                       n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Register();
    n6 = jj_consume_token(CLOSE_BRACKET);
                        n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(COMMA);
                n7 = JTBToolkit.makeNodeToken(n8);
    n9 = Register();
     {if (true) return new InstrStore(n0,n1,n2,n4,n5,n7,n9);}
    throw new Error("Missing return statement in function");
  }

  static final public OpStore OpStore() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 40:
      n2 = jj_consume_token(40);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 41:
      n4 = jj_consume_token(41);
                n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case 42:
      n6 = jj_consume_token(42);
                n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OpStore(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public InstrBranch InstrBranch() throws ParseException {
   OpBranch n0;
   Register n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n0 = OpBranch();
    n1 = Register();
    n3 = jj_consume_token(COMMA);
                n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(LABELJ);
                 n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new InstrBranch(n0,n1,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public OpBranch OpBranch() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      n2 = jj_consume_token(43);
                  n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 44:
      n4 = jj_consume_token(44);
                  n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OpBranch(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public InstrJumpReg InstrJumpReg() throws ParseException {
   OpJumpReg n0;
   Register n1;
    n0 = OpJumpReg();
    n1 = Register();
     {if (true) return new InstrJumpReg(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  static final public OpJumpReg OpJumpReg() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 45:
      n2 = jj_consume_token(45);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 46:
      n4 = jj_consume_token(46);
                  n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OpJumpReg(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public InstrJumpLab InstrJumpLab() throws ParseException {
   OpJumpLab n0;
   NodeToken n1;
   Token n2;
    n0 = OpJumpLab();
    n2 = jj_consume_token(LABELJ);
                 n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new InstrJumpLab(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  static final public OpJumpLab OpJumpLab() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
      n2 = jj_consume_token(47);
               n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 48:
      n4 = jj_consume_token(48);
                 n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OpJumpLab(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Nop Nop() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(49);
              n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new Nop(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Immed Immed() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(NUMBER);
                 n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new Immed(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Register Register() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
   NodeToken n31;
   Token n32;
   NodeToken n33;
   Token n34;
   NodeToken n35;
   Token n36;
   NodeToken n37;
   Token n38;
   NodeToken n39;
   Token n40;
   NodeToken n41;
   Token n42;
   NodeToken n43;
   Token n44;
   NodeToken n45;
   Token n46;
   NodeToken n47;
   Token n48;
   NodeToken n49;
   Token n50;
   NodeToken n51;
   Token n52;
   NodeToken n53;
   Token n54;
   NodeToken n55;
   Token n56;
   NodeToken n57;
   Token n58;
   NodeToken n59;
   Token n60;
   NodeToken n61;
   Token n62;
   NodeToken n63;
   Token n64;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 50:
      n2 = jj_consume_token(50);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case 51:
      n4 = jj_consume_token(51);
                n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case 52:
      n6 = jj_consume_token(52);
                n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case 53:
      n8 = jj_consume_token(53);
                n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case 54:
      n10 = jj_consume_token(54);
                 n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case 55:
      n12 = jj_consume_token(55);
                 n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case 56:
      n14 = jj_consume_token(56);
                 n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case 57:
      n16 = jj_consume_token(57);
                 n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case 58:
      n18 = jj_consume_token(58);
                 n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case 59:
      n20 = jj_consume_token(59);
                 n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case 60:
      n22 = jj_consume_token(60);
                  n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    case 61:
      n24 = jj_consume_token(61);
                  n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11);
      break;
    case 62:
      n26 = jj_consume_token(62);
                  n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12);
      break;
    case 63:
      n28 = jj_consume_token(63);
                  n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13);
      break;
    case 64:
      n30 = jj_consume_token(64);
                  n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14);
      break;
    case 65:
      n32 = jj_consume_token(65);
                  n31 = JTBToolkit.makeNodeToken(n32);
        n0 = new NodeChoice(n31, 15);
      break;
    case 66:
      n34 = jj_consume_token(66);
                  n33 = JTBToolkit.makeNodeToken(n34);
        n0 = new NodeChoice(n33, 16);
      break;
    case 67:
      n36 = jj_consume_token(67);
                  n35 = JTBToolkit.makeNodeToken(n36);
        n0 = new NodeChoice(n35, 17);
      break;
    case 68:
      n38 = jj_consume_token(68);
                  n37 = JTBToolkit.makeNodeToken(n38);
        n0 = new NodeChoice(n37, 18);
      break;
    case 69:
      n40 = jj_consume_token(69);
                  n39 = JTBToolkit.makeNodeToken(n40);
        n0 = new NodeChoice(n39, 19);
      break;
    case 70:
      n42 = jj_consume_token(70);
                  n41 = JTBToolkit.makeNodeToken(n42);
        n0 = new NodeChoice(n41, 20);
      break;
    case 71:
      n44 = jj_consume_token(71);
                  n43 = JTBToolkit.makeNodeToken(n44);
        n0 = new NodeChoice(n43, 21);
      break;
    case 72:
      n46 = jj_consume_token(72);
                  n45 = JTBToolkit.makeNodeToken(n46);
        n0 = new NodeChoice(n45, 22);
      break;
    case 73:
      n48 = jj_consume_token(73);
                  n47 = JTBToolkit.makeNodeToken(n48);
        n0 = new NodeChoice(n47, 23);
      break;
    case 74:
      n50 = jj_consume_token(74);
                  n49 = JTBToolkit.makeNodeToken(n50);
        n0 = new NodeChoice(n49, 24);
      break;
    case 75:
      n52 = jj_consume_token(75);
                  n51 = JTBToolkit.makeNodeToken(n52);
        n0 = new NodeChoice(n51, 25);
      break;
    case 76:
      n54 = jj_consume_token(76);
                  n53 = JTBToolkit.makeNodeToken(n54);
        n0 = new NodeChoice(n53, 26);
      break;
    case 77:
      n56 = jj_consume_token(77);
                  n55 = JTBToolkit.makeNodeToken(n56);
        n0 = new NodeChoice(n55, 27);
      break;
    case 78:
      n58 = jj_consume_token(78);
                  n57 = JTBToolkit.makeNodeToken(n58);
        n0 = new NodeChoice(n57, 28);
      break;
    case 79:
      n60 = jj_consume_token(79);
                  n59 = JTBToolkit.makeNodeToken(n60);
        n0 = new NodeChoice(n59, 29);
      break;
    case 80:
      n62 = jj_consume_token(80);
                  n61 = JTBToolkit.makeNodeToken(n62);
        n0 = new NodeChoice(n61, 30);
      break;
    case 81:
      n64 = jj_consume_token(81);
                  n63 = JTBToolkit.makeNodeToken(n64);
        n0 = new NodeChoice(n63, 31);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Register(n0);}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public EasyDLXParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0xfffffffe,0xffffe,0xfff00000,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x3ffff,0x0,0x7,0xf8,0x700,0x1800,0x6000,0x18000,0xfffc0000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffff,};
   }

  /** Constructor with InputStream. */
  public EasyDLXParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public EasyDLXParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new EasyDLXParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public EasyDLXParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new EasyDLXParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public EasyDLXParser(EasyDLXParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(EasyDLXParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[96];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 96; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}
